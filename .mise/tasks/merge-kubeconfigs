#!/usr/bin/env bash

#MISE description="Merge existing partial kubeconfigs into a single ~/.kube/config"
#
# This task only merges kubeconfigs already present in the partial directory.
# It does not download or copy source configs â€” use the fetch-kubeconfig task
# for that. The behavior is intentionally minimal: find partial kubeconfigs,
# include the existing ~/.kube/config (if present), flatten with kubectl, and
# atomically write the merged config to ~/.kube/config with a backup.
#
#USAGE flag "--partial-dir <dir>" help="Directory holding partial kubeconfigs" {
#USAGE }
#USAGE flag "--backup-dir <dir>" help="Directory to store backups of existing kubeconfig" {
#USAGE }

set -euo pipefail

PARTIAL_DIR="${usage_partial_dir:-${HOME}/.kube/partial}"
KUBECONFIG_FINAL="$HOME/.kube/config"

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || { echo "required command '$1' not found" >&2; exit 2; }
}

require_cmd kubectl
require_cmd mktemp
require_cmd date

mkdir -p "$PARTIAL_DIR"

# collect files to merge
shopt -s nullglob
partial_files=("$PARTIAL_DIR"/*)
if [[ ${#partial_files[@]} -eq 0 ]]; then
  echo "No kubeconfig files found in $PARTIAL_DIR to merge." >&2
  exit 5
fi

# build KUBECONFIG env var: include existing final config if present
kube_list=()
if [[ -f "$KUBECONFIG_FINAL" ]]; then
  kube_list+=("$KUBECONFIG_FINAL")
fi
for f in "${partial_files[@]}"; do kube_list+=("$f"); done

KUBECONFIG_JOIN=$(IFS=: ; echo "${kube_list[*]}")

# perform merge using kubectl
tmpmerged="$(mktemp)"
echo "Merging ${#kube_list[@]} configs -> $tmpmerged"
if ! KUBECONFIG="$KUBECONFIG_JOIN" kubectl config view --flatten --minify=false > "$tmpmerged"; then
  echo "kubectl config view failed" >&2
  rm -f "$tmpmerged"
  exit 6
fi

# atomically move into place
mkdir -p "$(dirname "$KUBECONFIG_FINAL")"
mv "$tmpmerged" "$KUBECONFIG_FINAL"
chmod 600 "$KUBECONFIG_FINAL"
echo "Merged kubeconfig written to $KUBECONFIG_FINAL (files merged: ${#kube_list[@]})"
echo "Partial directory: $PARTIAL_DIR"
